<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èµ°è¿·å®® - å¿«æ¨‚å­¸ç¿’æ¨‚åœ’</title>
    <link rel="stylesheet" th:href="@{/css/style.css}">
    <style>
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 1rem;
        }

        canvas {
            border: 4px solid var(--text-color);
            border-radius: 10px;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 100%;
        }

        .controls {
            margin-top: 1rem;
            display: grid;
            grid-template-columns: repeat(3, 60px);
            gap: 10px;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            border: none;
            background-color: var(--secondary-color);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 0 #2a8a84;
        }

        .control-btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .start-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 1rem 2rem;
            border-radius: 50px;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
            pointer-events: none;
            /* Let clicks pass through to canvas/player */
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>èµ°è¿·å®®</h1>
    </header>
    <main>
        <div class="nav-container">
            <a href="/games/menu" class="nav-link">â† å›ä¸Šä¸€é </a>
            <a href="/" class="nav-link home-link">ğŸ  å›é¦–é </a>
        </div>
        <div class="game-container" style="position: relative;">
            <canvas id="mazeCanvas" width="500" height="500"></canvas>
            <div id="start-msg" class="start-overlay">é»æ“Šæˆ–æ»‘å‹•é–‹å§‹ï¼</div>

            <div class="controls">
                <div></div>
                <button class="control-btn" onclick="movePlayer(0, -1)">â¬†ï¸</button>
                <div></div>
                <button class="control-btn" onclick="movePlayer(-1, 0)">â¬…ï¸</button>
                <button class="control-btn" onclick="movePlayer(0, 1)">â¬‡ï¸</button>
                <button class="control-btn" onclick="movePlayer(1, 0)">â¡ï¸</button>
            </div>
        </div>
    </main>

    <!-- Win Modal -->
    <div id="winModal" class="modal">
        <div class="modal-content">
            <h2 style="color: var(--primary-color); font-size: 2.5rem;">éé—œäº†ï¼ğŸ‰</h2>
            <p style="font-size: 1.5rem;">å¤ªå²å®³äº†ï¼è¦æŒ‘æˆ°ä¸‹ä¸€å€‹å—ï¼Ÿ</p>
            <div style="margin-top: 2rem;">
                <button onclick="location.href='/games/menu'" class="btn"
                    style="background-color: #95a5a6; margin-right: 1rem;">é›¢é–‹</button>
                <button onclick="location.href='/games/maze/loading'" class="btn">ä¸‹ä¸€å€‹è¿·å®®</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const startMsg = document.getElementById('start-msg');

        // Maze configuration
        const cols = 15; // Odd numbers work best for DFS
        const rows = 15;
        const cellSize = canvas.width / cols;
        let maze = [];
        let player = { x: 1, y: 1 };
        let end = { x: cols - 2, y: rows - 2 };
        let gameStarted = false;

        // è§¸æ§/æ»‘é¼ æ‹–æ›³ç›¸é—œè®Šæ•¸
        let isDragging = false;
        let lastTouchPos = null;
        const swipeThreshold = cellSize * 0.5; // æ»‘å‹•é–¾å€¼

        // Initialize
        function init() {
            // Generate random maze
            maze = generateMaze(cols, rows);
            // Ensure start and end are open
            maze[1][1] = 0;
            maze[rows - 2][cols - 2] = 0;

            player = { x: 1, y: 1 };
            gameStarted = false;
            startMsg.textContent = 'é»æ“Šè¿·å®®é–‹å§‹éŠæˆ²ï¼';
            startMsg.style.display = 'block';
            draw();

            // è¨­ç½®äº‹ä»¶ç›£è½å™¨
            setupEventListeners();
        }

        function setupEventListeners() {
            // é»æ“Šé–‹å§‹éŠæˆ²ï¼ˆé»æ“Šè¿·å®®ä»»æ„è™•ï¼‰
            canvas.addEventListener('click', handleCanvasClick);

            // æ»‘é¼ æ‹–æ›³æ§åˆ¶
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);

            // è§¸æ§æ»‘å‹•æ§åˆ¶
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
        }

        // é»æ“Šè¿·å®®ä»»æ„è™•é–‹å§‹éŠæˆ²
        function handleCanvasClick(e) {
            if (!gameStarted) {
                startGame();
            }
        }

        // ============ æ»‘é¼ æ‹–æ›³æ§åˆ¶ ============
        function handleMouseDown(e) {
            if (!gameStarted) return;
            isDragging = true;
            const rect = canvas.getBoundingClientRect();
            lastTouchPos = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function handleMouseMove(e) {
            if (!gameStarted || !isDragging || !lastTouchPos) return;

            const rect = canvas.getBoundingClientRect();
            const currentPos = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };

            processSwipe(lastTouchPos, currentPos);
        }

        function handleMouseUp(e) {
            isDragging = false;
            lastTouchPos = null;
        }

        // ============ è§¸æ§æ»‘å‹•æ§åˆ¶ ============
        function handleTouchStart(e) {
            e.preventDefault();
            if (!gameStarted) {
                startGame();
                return;
            }

            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            lastTouchPos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (!gameStarted || !lastTouchPos) return;

            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const currentPos = {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };

            processSwipe(lastTouchPos, currentPos);
        }

        function handleTouchEnd(e) {
            lastTouchPos = null;
        }

        // ============ æ»‘å‹•è™•ç†é‚è¼¯ ============
        function processSwipe(startPos, endPos) {
            const deltaX = endPos.x - startPos.x;
            const deltaY = endPos.y - startPos.y;

            // åˆ¤æ–·æ»‘å‹•æ–¹å‘ä¸¦ç§»å‹•ç©å®¶
            if (Math.abs(deltaX) > swipeThreshold || Math.abs(deltaY) > swipeThreshold) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // æ°´å¹³æ»‘å‹•
                    if (deltaX > 0) {
                        movePlayer(1, 0); // å‘å³
                    } else {
                        movePlayer(-1, 0); // å‘å·¦
                    }
                } else {
                    // å‚ç›´æ»‘å‹•
                    if (deltaY > 0) {
                        movePlayer(0, 1); // å‘ä¸‹
                    } else {
                        movePlayer(0, -1); // å‘ä¸Š
                    }
                }
                // æ›´æ–°èµ·å§‹ä½ç½®ä»¥å¯¦ç¾é€£çºŒæ»‘å‹•
                lastTouchPos = endPos;
            }
        }

        function startGame() {
            gameStarted = true;
            startMsg.style.display = 'none';
            draw();
        }

        function generateMaze(w, h) {
            // 1 = wall, 0 = path
            let grid = Array(h).fill().map(() => Array(w).fill(1));

            function carve(x, y) {
                const directions = [
                    [0, -2], [0, 2], [-2, 0], [2, 0]
                ].sort(() => Math.random() - 0.5);

                directions.forEach(([dx, dy]) => {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx > 0 && nx < w - 1 && ny > 0 && ny < h - 1 && grid[ny][nx] === 1) {
                        grid[y + dy / 2][x + dx / 2] = 0; // Remove wall between
                        grid[ny][nx] = 0; // Mark new cell as path
                        carve(nx, ny);
                    }
                });
            }

            grid[1][1] = 0;
            carve(1, 1);
            return grid;
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Maze
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = '#2C3E50'; // Wall color
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Draw End
            ctx.font = `${cellSize * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ğŸ', end.x * cellSize + cellSize / 2, end.y * cellSize + cellSize / 2);

            // Draw Player
            ctx.fillText('ğŸ‘·', player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);

            // If not started, show hint overlay
            if (!gameStarted) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Redraw player on top so they can see
                ctx.fillText('ğŸ‘·', player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);
            }
        }

        function movePlayer(dx, dy) {
            if (!gameStarted) return;

            const newX = player.x + dx;
            const newY = player.y + dy;

            // Check bounds and walls
            if (newX >= 0 && newX < cols && newY >= 0 && newY < rows && maze[newY][newX] === 0) {
                player.x = newX;
                player.y = newY;
                draw();
                checkWin();
            }
        }

        function checkWin() {
            if (player.x === end.x && player.y === end.y) {
                document.getElementById('winModal').style.display = 'flex';
                gameStarted = false;
            }
        }

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            // å¦‚æœéŠæˆ²å°šæœªé–‹å§‹ï¼Œä»»æ„æŒ‰éµçš†å¯é–‹å§‹
            if (!gameStarted) {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    startGame();
                    return;
                }
            }

            switch (e.key) {
                case 'ArrowUp': movePlayer(0, -1); e.preventDefault(); break;
                case 'ArrowDown': movePlayer(0, 1); e.preventDefault(); break;
                case 'ArrowLeft': movePlayer(-1, 0); e.preventDefault(); break;
                case 'ArrowRight': movePlayer(1, 0); e.preventDefault(); break;
            }
        });

        window.onload = init;
    </script>
</body>

</html>